---
title: "trying_sf_package_watershed"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load Packages

```{r}

library(tidyverse)
library(sf)
library(tmap)
library(leaflet)
library(readr)
library(raster)
library(rgdal)
library(sp)
library(broom)
library(ggmap)
library(progressr)
library(terrainr)
library(tiff)

```

Import Data

```{r}

AllWatersheds_LatLong <- read_csv("AllWatersheds_LatLong.csv")

AllWatersheds_LatLong <- AllWatersheds_LatLong %>%
  mutate(Unique_Site_ID = paste0(LTER, "_", Stream.Site)) 

AllWatersheds_LatLong$Unique_Site_ID <- as.factor(AllWatersheds_LatLong$Unique_Site_ID)

AllWatersheds_LatLong %>% group_by(Unique_Site_ID)


```

Remembering leaflet

```{r}

library(leaflet)

m <- leaflet() %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addMarkers(lng=174.768, lat=-36.852,
    popup="The birthplace of R")
m  # Print the map

```

```{r}

leaflet() %>% addCircles(data = AllWatersheds_LatLong)
leaflet() %>% addCircles(data = AllWatersheds_LatLong, lat = ~ Latitude, lng = ~ Longitude) %>% 
addTiles()

```
Switching it to a shape file

```{r}

AllWatersheds_LatLong_for_shp <- read.csv("AllWatersheds_LatLong.csv", stringsAsFactors = FALSE)


r <- SpatialPointsDataFrame(AllWatersheds_LatLong_for_shp[,3:4],
                    AllWatersheds_LatLong_for_shp)

# second, assign the CRS in one of two ways
r <- crs("+proj=utm +zone=18 +datum=WGS84 +units=m +no_defs 
                 +ellps=WGS84 +towgs84=0,0,0" )

plot.locations <- SpatialPointsDataFrame(AllWatersheds_LatLong_for_shp[,3:4],
                    AllWatersheds_LatLong_for_shp ,    #the R object to convert
                    proj4string = r) 


plot(plot.locations, 
     main="Map of Plot Locations")

```
```{r}

extent(plot.locations)



# add extra space to right of plot area; 
# par(mar=c(5.1, 4.1, 4.1, 8.1), xpd=TRUE)

plot(extent(plot.locations),
     col="purple", 
     xlab="Latitude",
     ylab="Longitude", lwd=8,
     main="Extent Boundary of Plot Locations \nCompared to the AOI Spatial Object"
)




```



```{r}

bbox <- make_bbox(lon = Longitude, lat = Latitude, AllWatersheds_LatLong, f = 0.05)

watershed_base_map <- get_map(location = bbox , maptype = "toner", source = "stamen")


ggmap(watershed_base_map) + geom_point(data = AllWatersheds_LatLong, mapping = aes(x = Longitude, y = Latitude)) + geom_point(data=AllWatersheds_LatLong, aes(x= Longitude, y= Latitude), color="navyblue", size = 3) + 
  theme(plot.subtitle = element_text(vjust = 1), 
    plot.caption = element_text(vjust = 1), 
    legend.text = element_text(face = "italic"), 
    legend.key = element_rect(fill = NA))  +
  labs(x = "Longitude", y = "Latitude")



```



Trying terrainr

terrainr is built to play nicely with functions from the sf and raster packages. In order to get our simulated points into the right format, we need to use the st_as_sf function from the sf package:

```{r}

HBR_only <- AllWatersheds_LatLong %>% filter(LTER == 'HBR')

HBR_only_points <- sf::st_as_sf(HBR_only,
                                 coords = c("Longitude", "Latitude"))

HBR_only_points <- sf::st_set_crs(HBR_only_points, 4326)

```

Now that we’ve got our data in the right format, it’s time to retrieve our data. terrainr currently supports downloading DEMs from the USGS 3D Elevation Program as well as orthoimages from the National Agricultural Imagery Program, in addition to other base map images from the National Map. These programs each have slightly different APIs and different restrictions on file types and the size of image you can download at once. Rather than make you think about this, terrainr handles all the edges of making API requests for you, including splitting your request into tiles and formatting the query.

For this vignette, we’ll retrieve both elevation and orthoimagery using the get_tiles function. We can either use the generic “elevation” and “ortho” shorthands to get our data, or we can specify “3DEPElevation” and “USGSNAIPPlus” to make sure we’re using the same specific service – the short codes aren’t guaranteed to download data from the same service between releases!

```{r}


handlers("progress")
with_progress( 
  output_files <- get_tiles(HBR_only_points,
                            output_prefix = tempfile(),
                            services = c("elevation", "ortho"))
  )



```

And just like that, we have our data tiles! To make multi-step processing easier, terrainr functions which deal with these tiles typically return lists of the file paths they saved your data to.
```{r}

output_files

```

If we were requesting more data than we can download at once, each element of the list would be a character vector containing the file paths for all of our downloaded tiles. Since we’re sticking with a relatively small area for this example, we only have one tile for each service.

As a quick aside, note that you can control where these files save to via the output_prefix argument (which appends the suffix servicename_xindex_yindex.tif to each tile it downloads) – you don’t need to save them to a temporary directory (and redownload every time you launch R) as we’re doing here!

If all you want is to access these endpoints to download data, this is probably the only terrainr function you’ll need – the files produced by this function can be processed just like any other spatial data:

```{r}

raster::plot(raster::raster(output_files[[1]]))

raster::plotRGB(raster::brick(output_files[[2]]), scale = 1)

```

In addition to the regular methods for plotting rasters in R, terrainr makes it a bit easier to use ggplot2 for plotting the data returned by get_tiles. Plotting single-band rasters, like our elevation file, is already well-supported in base ggplot2:

```{r}

elevation_raster <- raster::raster(output_files[[1]])
elevation_df <- as.data.frame(elevation_raster, xy = TRUE)
elevation_df <- setNames(elevation_df, c("x", "y", "elevation"))

ggplot() + 
  geom_raster(data = elevation_df, aes(x = x, y = y, fill = elevation)) + 
  scale_fill_distiller(palette = "BrBG") + 
  coord_sf(crs = 4326)

```
terrainr adds the ability to plot using multi-band RGB rasters, like the tiles downloaded for non-elevation endpoints, using the new geom_spatial_rgb function (or its partner, stat_spatial_rgb):

```{r}

ortho_raster <- raster::stack(output_files[[2]])
ortho_df <- as.data.frame(ortho_raster, xy = TRUE)
ortho_df <- setNames(ortho_df, c("x", "y", "red", "green", "blue"))

ggplot() + 
  geom_spatial_rgb(data = ortho_df,
                   # Required aesthetics r/g/b specify color bands:
                   aes(x = x, y = y, r = red, g = green, b = blue)) + 
  coord_sf(crs = 4326)

knitr::include_graphics("ortho_ggplot.jpg")

```
You can then use these multi-band rasters as base maps for further plotting as desired.

```{r}

ggplot() + 
  geom_spatial_rgb(data = output_files[[2]],
                   aes(x = x, y = y, r = red, g = green, b = blue)) + 
  geom_sf(data = HBR_only_points)

```
In case you find this visualization falls a little bit flat, terrainr also provides the ability to bring your landscapes into Unity to visualize in 3D. Our first step in this process is going to be replicating our image of base-map-plus-field-sites (above) in a format that we can import into Unity directly. First, we’ll need to use the vector_to_overlay function to create an image overlay from our point data:

```{r}

HBR_overlay <- vector_to_overlay(HBR_only_points,
                                       output_files[[2]],
                                       size = 15,
                                       color = "red")
knitr::include_graphics(HBR_overlay)

```
These overlays may be stacked on top of one another or downloaded imagery using the combine_overlays function:

```{r}

ortho_with_points <- combine_overlays(
  # Overlays are stacked in order, with the first file specified on the bottom
  output_files[[2]],
  HBR_overlay,
  output_file = tempfile(fileext = ".png")
  )
knitr::include_graphics(ortho_with_points)

```
Unfortunately, this image processing strips the georeferencing on the image. We can restore the original georeferencing via the georeference_overlay function:

```{r}

georef_overlay <- georeference_overlay(
  ortho_with_points,
  output_files[[2]]
)

```

We’ve been working so far with a single tile, but Unity is able to handle much, much larger rasters than we would normally work with in R. In order to create overlays for these larger rasters, it’s usually best to create an overlay for smaller image tiles which can then be joined back together with merge_rasters:

```{r}

tile_overlays <- lapply(output_files[[2]],
                        function(x) vector_to_overlay(HBR_only_points, 
                                                      x, 
                                                      size = 15, 
                                                      color = "red", 
                                                      na.rm = TRUE))

combined_tiles <- mapply(function(x, y) {
  combine_overlays(x, y, output_file = tempfile(fileext = ".png"))
  },                            
  output_files[[2]],
  tile_overlays)

georef_tiles <- mapply(georeference_overlay, combined_tiles, output_files[[2]])

merged_tiles <- merge_rasters(georef_tiles)

```

Of course, since we’re only working with a single tile, georef_tiles is identical to merged_tiles. But when working with larger areas, merged_tiles is particularly useful for joining the separate tiles downloaded by get_tiles into a single raster file.

In particular, having a single joined raster is necessary for the function raster_to_raw_tiles, which is designed to turn these larger rasters into tiles in a format that can be imported into the Unity 3D rendering engine. The specifics of working with Unity is outside of the scope of this overview vignette, other than to demonstrate the main way I call raster_to_raw_tiles:

```{r}

elevation_tile <- output_files[[1]]
side_length <- vapply(c(elevation_tile, georef_tiles), 
                      function(x) max(dim(raster::raster(x))), 
                      numeric(1))

mapply(function(x, y, z) {
  with_progress(
    raster_to_raw_tiles(input_file = x, 
                        output_prefix = "HBR", 
                        side_length = y, 
                        raw = z)
    )
},
  c(elevation_tile, georef_tiles),
  side_length, # What's the longer edge of our image file?
  c(TRUE, FALSE) # we don't want to convert our orthoimages to .raw;
)  

```

